# Домашнее задание 5

Написать REST API для регистрации и авторизации, и переписать логику работы с контактами так, чтобы только зарегистрированный пользователь мог добавлять контакты и каждый контакт записывался как добавленный конкретным пользователем. Для тестирования роутов используй [Postman](https://www.getpostman.com/). Работа должна быть создана в репозитории `hw05-register-auth`

## Шаг 1

В коллекцию `users` добавьте:

- обязательное поле `password`, в котором будет храниться пароль в захешированном виде;
- необязательное поле `token`

## Шаг 2

Создайте в приложении эндпоинт `auth` и добавьте в него такие роуты:

### @ POST /api/register

- Получает `body` в формате `{name, email, phone, passport, birthday, password, repeatPassword}` (все поля обязательны);
- если поля `password` и `repeatPassword` не совпадают, нужно возвращать 400 ошибку с текстом `password and passwordRepeat should be the same`;
- Если в body нет каких-то обязательных полей или они не соответствуют правилам валидации, возвращает ответ с статусом `400` и текстом ошибки;
- Если с `body` все хорошо, сохраняет пользователя в базу данных в коллекцию `users` (пароль должен сохраняться в захешированном виде);
- Если объект успешно сохранен в базе - возвращает объект с полями `{name, email}` и статусом `201`;

### @ POST /api/login

- Получает `body` в формате `{email, password}` (все поля обязательны);
- Если в body нет каких-то обязательных полей или они не соответствуют правилам валидации, возвращает ответ с статусом `400` и текстом ошибки;
- Если пользователя с таким email в базе нет, или пароль не совпадает с сохраненным в базе - возвращает 401 ошибку;
- Если все хорошо, создает и возвращает JWT-токен;

### @ GET /api/current

- Получает в заголовке `Authorization` `Bearer token`;
- если токен валиден и срок его действия не истек, возвращает объект с `{name, email}`;
- если токен не валиден или срок его действия истек, возвращает 401 ошибку;

### @ GET /api/logout

- Получает в заголовке `Authorization` `Bearer token`;
- если токен валиден и срок его действия не истек, обнуляет токен в базе данных;
- если токен не валиден или срок его действия истек, возвращает 401 ошибку;

## Шаг 3

Добавьте в коллекцию `contacts` еще одно поле `owner` - в нем будет храниться id пользователя, добавившего контакт.

## Шаг 4

Перепишите ваши роуты работы с контактами, добавив в них такую логику:

### @ GET /api/contacts

- для выполнения запроса пользователь должен быть авторизирован;
- возвращает массив всех контактов авторизированного пользователя в json-формате со статусом `200`

### @ GET /api/contacts/:id

- для выполнения запроса пользователь должен быть авторизирован;
- при поиске контакта по `id` нужно проверять, добавлял ли этот контакт текущий пользователь, отправивший запрос, и если нет - отправлять ответ с 404 статусом;

### @ POST /api/contacts

- для выполнения запроса пользователь должен быть авторизирован;
- при добавлении контакта в поле `owner` записывается `id` пользователя, отправившего запрос;

### @ PUT /api/contacts/:id

- для выполнения запроса пользователь должен быть авторизирован;
- при поиске контакта по `id` нужно проверять, добавлял ли этот контакт текущий пользователь, отправивший запрос, и если нет - отправлять ответ с 404 статусом;

### @ DELETE /api/contacts/:id

- для выполнения запроса пользователь должен быть авторизирован;
- при поиске контакта по `id` нужно проверять, добавлял ли этот контакт текущий пользователь, отправивший запрос, и если нет - отправлять ответ с 404 статусом;

### @ PATCH /api/contacts/:id/favorite

- для выполнения запроса пользователь должен быть авторизирован;
- при поиске контакта по `id` нужно проверять, добавлял ли этот контакт текущий пользователь, отправивший запрос, и если нет - отправлять ответ с 404 статусом;
